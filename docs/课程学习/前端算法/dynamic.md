动态规划题目的特征：
- 要求你给出达成某个目的的`解法个数`
- 不要求你给出每一种解法对应的具体路径

>题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。

示例：<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1. 1 阶 + 1 阶 <br>
2. 2 阶<br>

我们可以知道：
- f(1) = 1
- f(2) = 2
- f(n) = f(n-1) + f(n-2)

```
const climbStairs = function(n) {
    // 初始化状态数组
    const f = [];
    // 初始化已知值
    f[1] = 1;
    f[2] = 2;
    // 动态更新每一层楼梯对应的结果
    for(let i = 3;i <= n;i++){
        f[i] = f[i-2] + f[i-1];
    }
    // 返回目标值
    return f[n];
};
```

对于动态规划，优先选择这样的分析路径：
- 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系
- 结合记忆化搜索，明确状态转移方程
- 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。

