## JavaScript 中的内存管理

- 申请内存空间
- 使用内存空间
- 释放内存空间

```
# 申请
let obj = {}

# 使用
obj.name = 'jiang'

# 释放
obj = null
```

> 什么时候触发垃圾回收？当环境达到一定数量的变量，对象时执行回收，或者达到一定的
> 比例进行回收

## 合理的 GC 方案

### javascript 引擎基础 GC 方案：

- 引用计数：设置引用数，判断当前引用树是否为 0，数值为 0 则回收。使用引用计数器
  ，变量被引用+1，引用被删除-1，直到为 0 则回收
  - 可以即时回收垃圾对象
  - 减少程序卡顿时间
  - 无法回收循环引用的对象，对象之间相互引用，计数不为 0，无法被回收
  - 资源消耗较大
- 标记清除：遍历给可达对象打上标记，遍历清除没有打上标记的对象
  - 可以回收循环引用的对象
  - 容易产生碎片化空间，浪费空间
  - 不会立即回收垃圾对象
- 标记整理：标记清除的增强版，在清除前会整理顺序，将不活动对象统一清除
  - 减少碎片化空间
  - 不会立即回收垃圾对象

GC 的缺点，GC 时需要停止响应其它操作，这时需要优化：

- 分代回收：区分临时对象以及持久对象，多回收临时对象，少回收持久对象
- 增量 GC：就是每次处理一点，下次再处理一点，中断较多会带来上下文频繁切换到问题
  最终方案：(对象/s) 比率时，中断执行 GC 的频率，simple GC 更低些；如果大量对象
  都是长期“存活”，则分代处理优势也不大。
