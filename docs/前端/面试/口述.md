## 闭包
在看了重学前端课程后，在我的理解中，所有的函数其实都是闭包。什么是闭包，闭包是指有权访问另一个函数作用域中的变量的函数，闭包由环境与表达式组成，每个函数都至少会包含全局作用域。所以所有的函数都是闭包。

但是我们肯定不能单纯的这么去理解闭包，在实际应用中，大家对闭包的概念应该是，在一个函数中返回一个函数，这样就形成了闭包。先理解闭包的作用是什么，闭包其实在我的理解中是为了隐藏变量，保留变量的作用。在 return 的函数中保留了变量的，以便之后再次调用时使用，所以闭包实际上不能说会产生内存泄漏，因为这个不能被销毁的变量是我们主动去创造的，是需要使用的，内存泄漏是指无用的变量不能被回收。

那么这个变量是如何被存到函数中的呢，在函数执行完后，在执行上下文中会销毁定义的变量，但是这个变量在return的函数中被使用了，并且在外部被调用了，因此浏览器会保留这个return的子函数，并且把这个子函数的变量存到 closure 中，在浏览器的控制台中可见。

闭包的应用场景，比如说在一个循环中使用了定时器，定时器由于 eventloop 的原因会被加入到定时队列，等待执行，如果不使用闭包，那么在settimeout 中输出的变量都会是同一个，使用闭包就可以将for循环中的每次的变量都存到settimeout中，就是将变量隐藏到函数中。这就是闭包的场景之一。又比如说我们要计算一个东西，我们可以构造一个闭包，把预设值使用闭包计算好，之后调用这个方法就可以免去一些步骤。。。

## http 与 https
http 是以明文发士传输的超文本协议，端口是80，被人拦截请求后容易泄露

https 中的 s 指的就是 ssl 协议，需要申请ca证书，ssl协议 在传输层与应用层之间，能够对数据进行加密，验证身份，更加安全。端口是443

## http1.0 http1.1 http2.0
- http1.0: 每次请求都要建立一个 tcp 连接，每次都要进行三次握手，无法复用连接，会产生队头阻塞，服务器压力巨大
- http1.1：默认使用长连接，允许在请求时增加请求头：`connection:keep-alive`，这样在一段时间内能够复用之前的 TCP 连接，连接时长可以通过请求头的 `keep-alive`设置。长连接必须等待前一个请求的首个字节响应到达后，才能继续发送请求，避免产生队头阻塞。对于用一个协议，域名，端口，浏览器只允许同时打开6个TCP连接。新增响应头 `cache-control`,用于实现客户端缓存，支持断点续传
- http2.0：http1都是明文的文本传输，而http2.0则是使用二进制传输，基于一条 TCP 连接，多路复用，进行传输，每个传输都会带有一个id区分，这样就算传输的消息被打乱也能在另一端被正确重装，解决了队头阻塞问题。增加头部压缩。因为共用一个 TCP 连接，当发生丢包时，整个TCP都要等待重传。

## 如何做SEO
- 使用 title、desctiption、keywords 描述项目页面的内容
- 合理的使用语义化标签，让搜索引擎更容易理解网页
- 图片使用 alt，标签尽量使用一些辅助识别的功能，比如 aria
- 优化首屏加载速度
- 使用 next 等框架，避免 spa项目